#!/usr/bin/env python
"""
Description: Tool to view E-Tree operational data
Author: Bhavish Khatri
Company: Telstra

Copyright Telstra 2017
All Rights Reserved
"""
import argparse

from pprint import pprint
from prettytable import PrettyTable

import requests
import yaml

# Suppress SSL warnings
requests.packages.urllib3.disable_warnings(
    requests.packages.urllib3.exceptions.InsecureRequestWarning)

def main():
    """Main entry point"""
    args = get_args()
    switches = get_switch_names(args.filename)
    etrees = run_query_etrees()
    treepaths = run_query_treepaths()
    if args.raw:
        print_raw(etrees)
        print_raw(treepaths)
    if not args.no_table:
        print_table(etrees, treepaths, switches, args)

def get_args():
    """Sets up and collects command line arguments from user"""
    parser = argparse.ArgumentParser(description='List Operational Status of E-Trees')
    parser.add_argument('--raw', dest='raw', action='store_const',
                        help='Display raw API output', const=True, default=False)
    parser.add_argument('--no-table', dest='no_table', action='store_const',
                        help='Do no display tabular output of statuses', const=True, default=False)
    parser.add_argument('--topology', dest='filename', default='prod-topo.yml',
                        help='Specify a topology file [default=prod-topo.yml]')
    parser.add_argument('--show-errors', dest='show_errors', action='store_const',
                        help='Display error table with descriptions', const=True, default=False)
    parser.add_argument('--show-only-errors', dest='show_only_errors', action='store_const',
                        help='Display only the error table', const=True, default=False)
    args = parser.parse_args()
    return args

def get_switch_names(filename):
    """Parse yaml data from topology file to get switch names"""
    with open(filename, 'r') as infile:
        data = yaml.load(infile)
        return data['switch']

def run_query_etrees():
    """API call against BSC to get etree operational information"""
    url = 'https://10.61.80.243:8443/restconf/operational/brocade-bsc-etree:etrees'
    headers = {'authorization': 'Basic YWRtaW46YWRtaW4='}
    response = requests.request('GET', url, headers=headers, verify=False)
    return response.json()['etrees']['etree']

def run_query_treepaths():
    """API call against BSC to get treepath operational information"""
    url = 'https://10.61.80.243:8443/restconf/operational/brocade-bsc-tree-path:treepaths'
    headers = {'authorization': 'Basic YWRtaW46YWRtaW4='}
    response = requests.request('GET', url, headers=headers, verify=False)
    return response.json()['treepaths']['treepath']

def print_raw(result):
    """Pretty print raw information"""
    pprint(result)

def print_table(etrees, treepaths, switches, args):
    """Print tabuler data of operational status"""
    ptable = PrettyTable()
    ptable.field_names = ['E-Tree', 'Tree Up', 'Path Up', 'Flows Up', 'Root Switch', 'Root Port', 'Service-Label', 'Leaf']
    ptable.align['Treepath'] = 'l'
    ptable.align['Leaf'] = 'l'

    error_table = PrettyTable()
    error_table.field_names = ['Type', 'Name', 'Message']
    error_table.align = 'l'

    for etree in etrees:
        treepath = get_treepath(treepaths, etree['treepath-name'])
        stats = get_stats(etree['name'])

        data = []
        data.append(etree['name'])
        data.append(transform_bool(etree['state']['successful']))
        data.append(transform_bool(treepath['state']['successful']))
        data.append(transform_bool(stats['state']['successful']))

        data.append(get_switch_name(switches, treepath['root']['node']))
        data.append(etree['root']['matches'][0]['match']['in-port'])

        if 'brocade-bsc-etree-sr:mpls' in etree['root']:
            data.append(etree['root']['brocade-bsc-etree-sr:mpls']['service-label'])
        else:
            data.append('n/a')

        leaves = []
        if 'leaf' in etree['leaves']:
            for leaf in etree['leaves']['leaf']:
                port_list = []
                for action in leaf['action']:
                    if 'output-action' in action:
                        port_list.append(action['output-action']['output-node-connector'])

                if port_list.count > 0:
                    leaves.append(get_switch_name(switches, leaf['node']) +
                                  ' ' + ', '.join(port_list))

        outports = ''
        count = 1
        for leaf in leaves:
            if outports.count > 0:
                outports += '\n'
            outports += str(count) + ': ' + leaf
            count += 1
        data.append(outports)

        ptable.add_row(data)

        # Collect errors
        if not etree['state']['successful']:
            error_table.add_row(['E-Tree', etree['name'], etree['state']['message']])

        if not treepath['state']['successful']:
            error_table.add_row(['Treepath', treepath['name'], treepath['state']['message']])

        if not stats['state']['successful']:
            error_table.add_row(['Stats', etree['name'], stats['state']['message']])


    # Print table
    if not args.show_only_errors:
        print ptable.get_string(sortby=('E-Tree'))

    # Print error table
    if args.show_errors or args.show_only_errors:
        print '\nErrors:'
        print error_table.get_string(sortby=('Type'))

def get_stats(etree_name):
    """API call to BSC to get stats of a specific etree"""
    url = "https://10.61.80.243:8443/restconf/operations/brocade-bsc-etree:get-stats"
    headers = {'authorization': 'Basic YWRtaW46YWRtaW4=', 'content-type': 'application/json'}
    payload = '{"input\":{"name": "' + etree_name + '"}}'
    response = requests.request("POST", url, data=payload, headers=headers, verify=False)
    return response.json()['output']

def get_treepath(treepaths, name):
    """Find and return a single treepath given list of treepaths and a name"""
    for treepath in treepaths:
        if treepath['name'] == name:
            return treepath

def get_switch_name(switches, nodename):
    """Find a switch by its DPID and return the hostname"""
    dpid = nodename[9:]
    for switch in switches:
        if int(switch['dpid'], 16) == int(dpid):
            return switch['name']
    return dpid

def transform_bool(value):
    """Transform a True/False value to Yes/No instead"""
    if value:
        return 'Yes'
    else:
        return 'No'

if __name__ == '__main__':
    main()
