#!/usr/bin/env python
"""
Description: Tool to tabular flow data from NoviFlow switches
Author: Bhavish Khatri
Company: Telstra

Copyright Telstra 2017
All Rights Reserved
"""
from lib.novi import NoviFlow
from pprint import pprint
from prettytable import PrettyTable

import argparse
import re


def main():
    """Main method"""
    args = get_args()
    lines = get_flow_cli(args.switch, args.table)
    print_flows(lines, args.keepzeroes)
    # flows = parse_flows(lines)
    # print_table(flows)

def get_args():
    """Sets up and collects command line arguments from user"""
    parser = argparse.ArgumentParser(description='Show flows install in switch')
    parser.add_argument('switch')
    parser.add_argument('--table', dest='table', default='0')
    parser.add_argument('--keep-zeroes', dest='keepzeroes', action='store_const', const=True, default=False)
    args = parser.parse_args()
    return args

def get_flow_cli(switch, table):
    noviflow = NoviFlow()
    noviflow.connect(switch)
    noviflow.run('set config page off')
    flows = noviflow.run('show status flow tableid ' + table)
    noviflow.disconnect()

    lines = flows.splitlines()
    index = 0
    for line in lines:
        if line[0:9] == '[TABLE ' + table + ']':
            break
        index += 1

    lines = lines[index+1:]
    return lines

def print_flows(lines, keep_zeroes):
    """Parse flow output and print it in a tabular format sorted by packet count descending"""

    flow_id = re.compile('\[FLOW_ID\d+\]')
    packets = re.compile('Packet_count\s+=\s+(\d+)')

    # Fields to extract from each block
    fields = [
        {'name': 'flow_id', 'regex': '\[FLOW_ID(\d+)\]'},
        {'name': 'priority', 'regex': 'Priority\s+=\s+(\d+)'},
        {'name': 'packets', 'regex': 'Packet_count\s+=\s+(\d+)', 'type': 'int'},
        {'name': 'bytes', 'regex': 'Byte_count\s+=\s+(\d+)', 'type': 'int'},
        {'name': 'in_port', 'regex': 'OFPXMT_OFB_IN_PORT\s+=\s+(\d+)', 'type': 'int'},
        # {'name': 'eth_dst', 'regex': 'OFPXMT_OFB_ETH_DST\s+=\s+(\d+)'},
        # {'name': 'eth_src', 'regex': 'OFPXMT_OFB_ETH_SRC\s+=\s+(\d+)'},
        {'name': 'eth_type', 'regex': 'OFPXMT_OFB_ETH_TYPE\s+=\s+(0x\d+)'},
        {'name': 'vlan', 'regex': 'OFPXMT_OFB_VLAN_VID\s+=\s+(\d+)', 'type': 'int'},
        # {'name': 'pcp', 'regex': 'OFPXMT_OFB_VLAN_PCP\s+=\s+(\d+)', 'type': 'int'},
        {'name': 'ip_proto', 'regex': 'OFPXMT_OFB_IP_PROTO\s+=\s+(\d+)'},
        {'name': 'ipv4_src', 'regex': 'OFPXMT_OFB_IPV4_SRC\s+=\s+(\d+\.\d+\.\d+\.\d+)'},
        {'name': 'ipv4_dst', 'regex': 'OFPXMT_OFB_IPV4_DST\s+=\s+(\d+\.\d+\.\d+\.\d+)'},
        {'name': 'tcp_src', 'regex': 'OFPXMT_OFB_TCP_SRC\s+=\s+(\d+)'},
        {'name': 'tcp_dst', 'regex': 'OFPXMT_OFB_TCP_DST\s+=\s+(\d+)'},
        {'name': 'udp_src', 'regex': 'OFPXMT_OFB_UDP_SRC\s+=\s+(\d+)'},
        {'name': 'udp_dst', 'regex': 'OFPXMT_OFB_UDP_DST\s+=\s+(\d+)'},
    ]
    for field in fields:
        field['rex'] = re.compile(field['regex'])

    ptable = PrettyTable()
    field_names = []
    for field in fields:
        field_names.append(field['name'])
    ptable.field_names = field_names

    flow_block=''
    for line in lines:
        if flow_id.search(line):
            if len(flow_block) > 0:
                record = []
                for field in fields:
                    record.append(get_value(flow_block, field))
                if keep_zeroes or int(packets.search(flow_block).group(1)) > 0:
                    ptable.add_row(record)

                record = []
                flow_block = line
        else:
            flow_block += line + '\n'

    print ptable.get_string(sortby='packets', reversesort=True)

def get_value(string, field, default='*'):
    """
    Given a string and a field set which contains a regular expression in 'rex' and an indicator to
    treat the value as a number or not, return either the value found or the default
    """
    match = field['rex'].search(string)
    if match:
        if 'type' in field and field['type'] == 'int':
            return int(match.group(1))
        else:
            return match.group(1)
    return default

if __name__ == '__main__':
    main()
