#!/usr/bin/env python
"""
Description: Tool to tabular flow data from NoviFlow switches
Author: Bhavish Khatri
Company: Telstra

Copyright Telstra 2017
All Rights Reserved
"""
from lib.novi import NoviFlow
from pprint import pprint
from prettytable import PrettyTable

import argparse
import operator
import re

ARGS = None

def main():
    """Main method"""
    args = get_args()
    lines = get_flow_cli()
    print_flows(lines)

def get_args():
    """Sets up and collects command line arguments from user"""
    global ARGS
    parser = argparse.ArgumentParser(description='Show flows install in switch')
    parser.add_argument('switch')
    parser.add_argument('--table', dest='table', default='0')
    parser.add_argument('--zeroes', dest='keep_zeroes', action='store_const', const=True, default=False, help='Keep zeroes')
    parser.add_argument('--filter', dest='filter', type=str)
    parser.add_argument('--html', dest='html', action='store_const', const=True, default=False)
    ARGS = parser.parse_args()

def get_flow_cli():
    noviflow = NoviFlow()
    noviflow.connect(ARGS.switch)
    noviflow.run('set config page off')
    flows = noviflow.run('show status flow tableid ' + ARGS.table)
    noviflow.disconnect()

    lines = flows.splitlines()
    index = 0
    for line in lines:
        if line[0:9] == '[TABLE ' + ARGS.table + ']':
            break
        index += 1

    lines = lines[index+1:]
    return lines

def print_flows(lines):
    """Parse flow output and print it in a tabular format sorted by packet count descending"""

    flow_id = re.compile('\[FLOW_ID\d+\]')
    packets = re.compile('Packet_count\s+=\s+(\d+)')

    # Fields to extract from each block
    fields = [
        {'name': 'flow_id', 'regex': '\[FLOW_ID(\d+)\]'},
        {'name': 'priority', 'regex': 'Priority\s+=\s+(\d+)'},
        {'name': 'packets', 'regex': 'Packet_count\s+=\s+(\d+)', 'type': 'int'},
        {'name': 'bytes', 'regex': 'Byte_count\s+=\s+(\d+)', 'type': 'int'},
        {'name': 'in_port', 'regex': 'OFPXMT_OFB_IN_PORT\s+=\s+(\d+)', 'type': 'int'},
        # {'name': 'eth_dst', 'regex': 'OFPXMT_OFB_ETH_DST\s+=\s+(\d+)'},
        # {'name': 'eth_src', 'regex': 'OFPXMT_OFB_ETH_SRC\s+=\s+(\d+)'},
        {'name': 'eth_type', 'regex': 'OFPXMT_OFB_ETH_TYPE\s+=\s+(0x\w+)'},
        {'name': 'vlan', 'regex': 'OFPXMT_OFB_VLAN_VID\s+=\s+(\d+)', 'type': 'int'},
        # {'name': 'pcp', 'regex': 'OFPXMT_OFB_VLAN_PCP\s+=\s+(\d+)', 'type': 'int'},
        {'name': 'ip_proto', 'regex': 'OFPXMT_OFB_IP_PROTO\s+=\s+(\d+)'},
        {'name': 'ipv4_src', 'regex': 'OFPXMT_OFB_IPV4_SRC\s+=\s+(\d+\.\d+\.\d+\.\d+)'},
        {'name': 'ipv4_dst', 'regex': 'OFPXMT_OFB_IPV4_DST\s+=\s+(\d+\.\d+\.\d+\.\d+)'},
        {'name': 'tcp_src', 'regex': 'OFPXMT_OFB_TCP_SRC\s+=\s+(\d+)'},
        {'name': 'tcp_dst', 'regex': 'OFPXMT_OFB_TCP_DST\s+=\s+(\d+)'},
        {'name': 'udp_src', 'regex': 'OFPXMT_OFB_UDP_SRC\s+=\s+(\d+)'},
        {'name': 'udp_dst', 'regex': 'OFPXMT_OFB_UDP_DST\s+=\s+(\d+)'},
    ]
    for field in fields:
        field['rex'] = re.compile(field['regex'])

    ptable = PrettyTable()
    field_names = []
    for field in fields:
        field_names.append(field['name'])
    ptable.field_names = field_names

    flow_block=''
    rows = []
    for line in lines:
        if flow_id.search(line):
            if len(flow_block) > 0:
                record = []
                for field in fields:
                    record.append(get_value(flow_block, field))
                if ARGS.keep_zeroes or int(packets.search(flow_block).group(1)) > 0:
                    #ptable.add_row(record)
                    rows.append(record)

                record = []
                flow_block = line
        else:
            flow_block += line + '\n'

    filter_and_print(ptable, rows, operator.itemgetter(2))

def get_value(string, field, default='*'):
    """
    Given a string and a field set which contains a regular expression in 'rex' and an indicator to
    treat the value as a number or not, return either the value found or the default
    """
    match = field['rex'].search(string)
    if match:
        if 'type' in field and field['type'] == 'int':
            return int(match.group(1))
        else:
            return match.group(1)
    return default

def filter_and_print(ptable, rows, sort_key):
    # Filter entries
    if ARGS.filter:
        test = re.compile(str(ARGS.filter), re.IGNORECASE)
        new_rows = []
        for row in rows:
            match = False
            for item in row:
                if test.search(str(item)):
                    match = True
                    break
            if match:
                new_rows.append(row)
        rows = new_rows

    # Sort and print table
    rows = sorted(rows, key=sort_key)
    for row in rows:
        ptable.add_row(row)

    if ARGS.html:
        print ptable.get_html_string()
    else:
        print ptable.get_string()

if __name__ == '__main__':
    main()
