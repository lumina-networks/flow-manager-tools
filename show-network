#!/usr/bin/env python
"""
Description: Tool to list Operational Status of SEN Network
Author: Bhavish Khatri
Company: Telstra

Copyright Telstra 2017
All Rights Reserved
"""
import argparse

from fmtopo.topo import _get_switch_port_status_noviflow
from fmtopo.topo import _get_switch_version_noviflow
from pprint import pprint
from prettytable import PrettyTable

import operator
import re
import requests
import threading
import yaml

# Suppress SSL warnings
requests.packages.urllib3.disable_warnings(
    requests.packages.urllib3.exceptions.InsecureRequestWarning)

SWITCHES = None
ARGS = None
LINKS = None
PORTS = None
VERSIONS = None

def main():
    global ARGS
    global switches
    """Main entry point"""
    ARGS = get_args()
    load_switches(ARGS.filename)
    load_links(ARGS.filename)
    get_port_status_all()
    if ARGS.versions:
        get_versions_all()
        print_versions()
    print_topology()

def get_args():
    """Sets up and collects command line arguments from user"""
    parser = argparse.ArgumentParser(description='List Operational Status of SEN Network')
    parser.add_argument('--topology', dest='filename', default='prod-topo.yml',
                        help='Specify a topology file [default=prod-topo.yml]')
    parser.add_argument('--id', dest='show_id', action='store_const', const=True, default=False)
    parser.add_argument('--filter', dest='filter', type=str)
    parser.add_argument('--uni', dest='unidirectional', action='store_const', const=True, default=False)
    parser.add_argument('--versions', dest='versions', action='store_const', const=True, default=False)
    args = parser.parse_args()
    return args

def load_switches(filename):
    """Parse yaml data from topology file to get switch names"""
    global SWITCHES
    with open(filename, 'r') as infile:
        data = yaml.load(infile)
        SWITCHES = data['switch']

def load_links(filename):
    global LINKS
    with open(filename, 'r') as infile:
        data = yaml.load(infile)
        LINKS = data['link']
    for link in LINKS:
        link['destination'] = link['destination'].upper()
        link['source'] = link['source'].upper()

def get_port_status_all():
    """Multi-threaded function to collect port stats from all switches"""
    global PORTS
    PORTS = {}
    threads = []
    # Create threads
    for switch in SWITCHES:
        thread = threading.Thread(target=get_port_status, args=(switch,))
        threads.append(thread)
        thread.start()

    # Join
    for thread in threads:
        thread.join()

def get_port_status(switch):
    """Retrieve port stats from a single switch and add data to dict"""
    ports = _get_switch_port_status_noviflow(switch['ip'], 22, switch['user'], switch['password'])
    PORTS[switch['name']] = ports

def get_versions_all():
    global VERSIONS
    VERSIONS = {}
    threads = []
    # Create threads
    for switch in SWITCHES:
        thread = threading.Thread(target=get_version, args=(switch,))
        threads.append(thread)
        thread.start()

    # Join
    for thread in threads:
        thread.join()

def get_version(switch):
    version = _get_switch_version_noviflow(switch['ip'], 22, switch['user'], switch['password'])
    VERSIONS[switch['name']] = version

def get_switch_name(nodename):
    """Find a switch by its DPID and return the hostname"""
    dpid = nodename[9:]
    for switch in SWITCHES:
        if int(switch['dpid'], 16) == int(dpid):
            return switch['name']
    return dpid

def get_switch_nodename(name):
    for switch in SWITCHES:
        if switch['name'] == name:
            return 'openflow:' + str(int(switch['dpid'], 16))
    return name

def run_query_topology():
    """API call against BSC to get topology information"""
    url = 'https://10.61.80.243:8443/restconf/operational/network-topology:network-topology/topology/flow:1'
    headers = {'authorization': 'Basic YWRtaW46YWRtaW4='}
    response = requests.request('GET', url, headers=headers, verify=False)
    return response.json()['topology'][0]

def print_versions():
    """Tabular view of the version of the noviflow switch versions"""
    ptable = PrettyTable()
    ptable.field_names = ['Device', 'Version']
    for switch, version in VERSIONS.items():
        ptable.add_row([switch, version])
    print 'Noviflow Operational Software Versions'
    print '--------------------------------------'
    print ptable.get_string(sortby='Device')
    print ''

def print_topology():
    """Print tabuler data of operational status"""

    fields = [
        ['Device', 'Hostname + DPID (with --id option)'],
        ['Port', 'Physical port on switch'],
        ['Connected To', 'Hostname for other end of connection'],
        ['On Port', 'Physical port on other end switch'],
        ['Port Status', 'Operational Status of link as reported by Noviware'],
        ['LLDP Status', 'Link discovery Status from Controller'],
        ['Build', 'Comparing against planned topology: Good or Required / Wrong Cabling if not good']
    ]

    print 'Network Topology Operational Status'
    print '-----------------------------------'
    print '\nKey:'
    pfields = []
    for field in fields:
        pfields.append(field[0])
        print ' :-', field[0], '-', field[1]

    ptable = PrettyTable()
    ptable.field_names = pfields
    ptable.align['Device'] = 'l'
    ptable.align['Port'] = 'r'
    ptable.align['Connected To'] = 'l'
    ptable.align['On Port'] = 'r'

    links = run_query_topology()['link']

    rows = []
    for link in links:
        device = get_switch_name(link['source']['source-node'])
        port = int(link['source']['source-tp'].split(':')[2])
        connected_to = get_switch_name(link['destination']['dest-node'])
        on_port = int(link['destination']['dest-tp'].split(':')[2])
        port_status = PORTS[device][port]['oper'].title()
        lldp_status = 'Unidirectional'

        # Find reverse path
        for other in links:
            if other['source']['source-tp'] == link['destination']['dest-tp'] and \
                other['destination']['dest-tp'] == link['source']['source-tp']:
                    lldp_status = 'Bidirectional'
                    break

        # Find link in configuration
        build = 'Wrong Cabling'
        for defined in LINKS:
            if defined['destination'] == device and defined['destination_port'] == port and \
                defined['source'] == connected_to and defined['source_port'] == on_port:
                    build = 'Good'
                    break

        if ARGS.show_id:
            device += ' (' + link['source']['source-node'] + ')'
            connected_to += ' (' + link['destination']['dest-node'] + ')'

        rows.append([device, port, connected_to, on_port, port_status, lldp_status, build])

    # Loop through configured links and add if not found in topology
    for defined in LINKS:
        found_forward = False
        found_reverse = False
        for link in links:
            device = get_switch_name(link['source']['source-node'])
            port = int(link['source']['source-tp'].split(':')[2])
            connected_to = get_switch_name(link['destination']['dest-node'])
            on_port = int(link['destination']['dest-tp'].split(':')[2])
            
            if defined['destination'] == device and defined['destination_port'] == port and \
                defined['source'] == connected_to and defined['source_port'] == on_port:
                    found_forward = True
                
            if defined['destination'] == connected_to and defined['destination_port'] == on_port and \
                defined['source'] == device and defined['source_port'] == port:
                    found_reverse = True

        device = defined['destination']
        port = int(defined['destination_port'])
        connected_to = defined['source']
        on_port = int(defined['source_port'])

        if ARGS.show_id:
            device += ' (' + get_switch_nodename(device) + ')'
            connected_to += ' (' + get_switch_nodename(connected_to) + ')' 

        if not found_forward:
            lldp_status = 'Missing'
            build = 'Required'
            port_status = PORTS[device][port]['oper'].title()
            rows.append([device, port, connected_to, on_port, port_status, lldp_status, build])

    # Filter entries
    if ARGS.filter:
        test = re.compile(ARGS.filter, re.IGNORECASE)
        new_rows = []
        for row in rows:
            match = False
            for item in row:
                if test.match(str(item)):
                    match = True
                    break
            if match:
                new_rows.append(row)
        rows = new_rows

    # Sort and print table
    rows = sorted(rows, key=operator.itemgetter(1, 0))
    for row in rows:
        ptable.add_row(row)
    print ptable.get_string(sortby=('Device'))

if __name__ == '__main__':
    main()

