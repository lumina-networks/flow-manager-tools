#!/usr/bin/env python
"""
Description: Tool to list Operational Status of SEN Network
Author: Bhavish Khatri
Company: Telstra

Copyright Telstra 2017
All Rights Reserved
"""
import argparse

from fmtopo.topo import _get_switch_port_status_noviflow
from fmtopo.topo import _get_switch_version_noviflow
from pprint import pprint
from prettytable import PrettyTable

import operator
import re
import requests
import threading
import yaml

# Suppress SSL warnings
requests.packages.urllib3.disable_warnings(
    requests.packages.urllib3.exceptions.InsecureRequestWarning)

CUSTOMERS = None
LINKS = None
SWITCHES = None
ARGS = None
PORTS = None
VERSIONS = None

def main():
    global ARGS
    global switches
    """Main entry point"""
    ARGS = get_args()
    load_topology(ARGS.filename)

    if ARGS.versions:
        get_versions_all()
        print_versions()
    else:
        get_port_status_all()
        if ARGS.customers:
            print_customers()
        else:
            print_topology()

def get_args():
    """Sets up and collects command line arguments from user"""
    parser = argparse.ArgumentParser(description='List Operational Status of SEN Network')
    parser.add_argument('--topology', dest='filename', default='prod-topo.yml',
                        help='Specify a topology file [default=prod-topo.yml]')
    parser.add_argument('--id', dest='show_id', action='store_const', const=True, default=False)
    parser.add_argument('--filter', dest='filter', type=str)
    parser.add_argument('--uni', dest='unidirectional', action='store_const', const=True, default=False)
    parser.add_argument('--versions', dest='versions', action='store_const', const=True, default=False)
    parser.add_argument('--customers', dest='customers', action='store_const', const=True, default=False)
    parser.add_argument('--html', dest='html', action='store_const', const=True, default=False)
    args = parser.parse_args()
    return args

def load_topology(filename):
    """Parse yaml data from topology file"""
    global CUSTOMERS
    global LINKS
    global SWITCHES

    # Load from yaml into globals
    with open(filename, 'r') as infile:
        data = yaml.load(infile)
        LINKS = data['link']
        SWITCHES = data['switch']
        CUSTOMERS = data['customers']

    # Normalize data
    for link in LINKS:
        link['destination'] = link['destination'].upper()
        link['source'] = link['source'].upper()
    
    for customer in CUSTOMERS:
        customer['hostname'] = customer['hostname'].upper()
        customer['port'] = int(customer['port'])

def get_port_status_all():
    """Multi-threaded function to collect port stats from all switches"""
    global PORTS
    PORTS = {}
    threads = []
    # Create threads
    for switch in SWITCHES:
        thread = threading.Thread(target=get_port_status, args=(switch,))
        threads.append(thread)
        thread.start()

    # Join
    for thread in threads:
        thread.join()

def get_port_status(switch):
    """Retrieve port stats from a single switch and add data to dict"""
    ports = _get_switch_port_status_noviflow(switch['ip'], 22, switch['user'], switch['password'])
    PORTS[switch['name']] = ports

def get_versions_all():
    global VERSIONS
    VERSIONS = {}
    threads = []
    # Create threads
    for switch in SWITCHES:
        thread = threading.Thread(target=get_version, args=(switch,))
        threads.append(thread)
        thread.start()

    # Join
    for thread in threads:
        thread.join()

def get_version(switch):
    version = _get_switch_version_noviflow(switch['ip'], 22, switch['user'], switch['password'])
    VERSIONS[switch['name']] = version

def get_switch_name(nodename):
    """Find a switch by its DPID and return the hostname"""
    dpid = nodename[9:]
    for switch in SWITCHES:
        if int(switch['dpid'], 16) == int(dpid):
            return switch['name']
    return dpid

def get_switch_nodename(name):
    for switch in SWITCHES:
        if switch['name'] == name:
            return 'openflow:' + str(int(switch['dpid'], 16))
    return name

def run_query_topology():
    """API call against BSC to get topology information"""
    url = 'https://10.61.80.243:8443/restconf/operational/network-topology:network-topology/topology/flow:1'
    headers = {'authorization': 'Basic YWRtaW46YWRtaW4='}
    response = requests.request('GET', url, headers=headers, verify=False)
    return response.json()['topology'][0]

def print_versions():
    """Tabular view of the version of the noviflow switch versions"""
    ptable = PrettyTable()
    ptable.field_names = ['Device', 'Version']
    rows = []
    for switch, version in VERSIONS.items():
        rows.append([switch, version])

    print_title('Noviflow Operational Software Versions')
    filter_and_print(ptable, rows, operator.itemgetter(0))
    
def print_customers():
    """Print tabular data of Customer Connection Operational State"""
    ptable = PrettyTable()
    ptable.field_names = ['Device', 'Port', 'Connects To', 'Customer', 'Oper State']

    rows = []
    for customer in CUSTOMERS:
        device = customer['hostname']
        port = customer['port']
        connects_to = customer['connects_to']
        customer_name = customer['customer']
        port_status = 'Down'

        try:
            port_status = PORTS[device][port]['oper'].title()
        except:
            pass

        rows.append([device, port, connects_to, customer_name, port_status])

    print_title('Customer Connection Operational Status')
    filter_and_print(ptable, rows, operator.itemgetter(3, 0, 1))

def print_topology():
    """Print tabuler data of operational status"""

    fields = [
        ['Device', 'Hostname + DPID (with --id option)'],
        ['Port', 'Physical port on switch'],
        ['Connected To', 'Hostname for other end of connection'],
        ['On Port', 'Physical port on other end switch'],
        ['Port Status', 'Operational Status of link as reported by Noviware'],
        ['LLDP Status', 'Link discovery Status from Controller'],
        ['Build', 'Comparing against planned topology: Good or Required / Wrong Cabling if not good']
    ]

    print_title('Network Topology Operational Status')

    info = 'Key:\n'
    pfields = []
    for field in fields:
        pfields.append(field[0])
        info += ' :- ' + field[0] + ' - ' + field[1] + '\n'

    print_info(info)

    ptable = PrettyTable()
    ptable.field_names = pfields
    ptable.align['Device'] = 'l'
    ptable.align['Port'] = 'r'
    ptable.align['Connected To'] = 'l'
    ptable.align['On Port'] = 'r'

    links = run_query_topology()['link']

    rows = []
    for link in links:
        device = get_switch_name(link['source']['source-node'])
        port = int(link['source']['source-tp'].split(':')[2])
        connected_to = get_switch_name(link['destination']['dest-node'])
        on_port = int(link['destination']['dest-tp'].split(':')[2])
        port_status = PORTS[device][port]['oper'].title()
        lldp_status = 'Unidirectional'

        # Find reverse path
        for other in links:
            if other['source']['source-tp'] == link['destination']['dest-tp'] and \
                other['destination']['dest-tp'] == link['source']['source-tp']:
                    lldp_status = 'Bidirectional'
                    break

        # Find link in configuration
        build = 'Wrong Cabling'
        for defined in LINKS:
            if defined['destination'] == device and defined['destination_port'] == port and \
                defined['source'] == connected_to and defined['source_port'] == on_port:
                    build = 'Good'
                    break

        if ARGS.show_id:
            device += ' (' + link['source']['source-node'] + ')'
            connected_to += ' (' + link['destination']['dest-node'] + ')'

        rows.append([device, port, connected_to, on_port, port_status, lldp_status, build])

    # Loop through configured links and add if not found in topology
    for defined in LINKS:
        found_forward = False
        found_reverse = False
        for link in links:
            device = get_switch_name(link['source']['source-node'])
            port = int(link['source']['source-tp'].split(':')[2])
            connected_to = get_switch_name(link['destination']['dest-node'])
            on_port = int(link['destination']['dest-tp'].split(':')[2])
            
            if defined['destination'] == device and defined['destination_port'] == port and \
                defined['source'] == connected_to and defined['source_port'] == on_port:
                    found_forward = True
                
            if defined['destination'] == connected_to and defined['destination_port'] == on_port and \
                defined['source'] == device and defined['source_port'] == port:
                    found_reverse = True

        device = defined['destination']
        port = int(defined['destination_port'])
        connected_to = defined['source']
        on_port = int(defined['source_port'])

        if ARGS.show_id:
            device += ' (' + get_switch_nodename(device) + ')'
            connected_to += ' (' + get_switch_nodename(connected_to) + ')' 

        if not found_forward:
            lldp_status = ''
            build = 'Required'
            if device in PORTS:
                port_status = PORTS[device][port]['oper'].title()
                if port_status == 'Up':
                    lldp_status = 'Missing'
                else:
                    lldp_status == 'n/a'
            else:
                port_status = 'n/a'
            rows.append([device, port, connected_to, on_port, port_status, lldp_status, build])

    filter_and_print(ptable, rows, operator.itemgetter(0, 1))

def print_title(text):
    if ARGS.html:
        print '<h1>' + text + '</h1>'
    else:
        print text + '\n'

def print_info(text):
    if ARGS.html:
        print '<pre>' + text + '</pre>'
    else:
        print text + '\n'

def filter_and_print(ptable, rows, sort_key):
    # Filter entries
    if ARGS.filter:
        test = re.compile(ARGS.filter, re.IGNORECASE)
        new_rows = []
        for row in rows:
            match = False
            for item in row:
                if test.search(str(item)):
                    match = True
                    break
            if match:
                new_rows.append(row)
        rows = new_rows

    # Sort and print table
    rows = sorted(rows, key=sort_key)
    for row in rows:
        ptable.add_row(row)

    if ARGS.html:
        print '<div class="table-responsive">'
        print ptable.get_html_string(border=True, attributes={'class': 'table table-striped table-condensed'})
        print '</div>'
    else:
        print ptable.get_string()

if __name__ == '__main__':
    main()

