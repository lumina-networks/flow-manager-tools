#!/usr/bin/env python
"""
Description: Tool to list Operational Status of SEN Network
Author: Bhavish Khatri
Company: Telstra

Copyright Telstra 2017
All Rights Reserved
"""
import argparse

from pprint import pprint
from prettytable import PrettyTable

import operator
import re
import requests
import yaml

# Suppress SSL warnings
requests.packages.urllib3.disable_warnings(
    requests.packages.urllib3.exceptions.InsecureRequestWarning)

SWITCHES = None
ARGS = None
LINKS = None

def main():
    global ARGS
    global switches
    """Main entry point"""
    ARGS = get_args()
    load_switches(ARGS.filename)
    load_links(ARGS.filename)
    print_table()

def get_args():
    """Sets up and collects command line arguments from user"""
    parser = argparse.ArgumentParser(description='List Operational Status of SEN Network')
    parser.add_argument('--topology', dest='filename', default='prod-topo.yml',
                        help='Specify a topology file [default=prod-topo.yml]')
    parser.add_argument('--id', dest='show_id', action='store_const', const=True, default=False)
    parser.add_argument('--filter', dest='filter', type=str)
    args = parser.parse_args()
    return args

def load_switches(filename):
    """Parse yaml data from topology file to get switch names"""
    global SWITCHES
    with open(filename, 'r') as infile:
        data = yaml.load(infile)
        SWITCHES = data['switch']

def load_links(filename):
    global LINKS
    with open(filename, 'r') as infile:
        data = yaml.load(infile)
        LINKS = data['link']
    for link in LINKS:
        link['destination'] = link['destination'].upper()
        link['source'] = link['source'].upper()

def get_switch_name(nodename):
    """Find a switch by its DPID and return the hostname"""
    dpid = nodename[9:]
    for switch in SWITCHES:
        if int(switch['dpid'], 16) == int(dpid):
            return switch['name']
    return dpid

def get_switch_nodename(name):
    for switch in SWITCHES:
        if switch['name'] == name:
            return 'openflow:' + str(int(switch['dpid'], 16))
    return name

def run_query_topology():
    """API call against BSC to get topology information"""
    url = 'https://10.61.80.243:8443/restconf/operational/network-topology:network-topology/topology/flow:1'
    headers = {'authorization': 'Basic YWRtaW46YWRtaW4='}
    response = requests.request('GET', url, headers=headers, verify=False)
    return response.json()['topology'][0]


def print_table():
    """Print tabuler data of operational status"""

    ptable = PrettyTable()
    ptable.field_names = ['Device', 'Port', 'Connected To', 'On Port', 'Status', 'Bidirectional', 'Build']
    ptable.align['Device'] = 'l'
    ptable.align['Port'] = 'r'
    ptable.align['Connected To'] = 'l'
    ptable.align['On Port'] = 'r'

    links = run_query_topology()['link']

    rows = []
    for link in links:
        device = get_switch_name(link['source']['source-node'])
        port = int(link['source']['source-tp'].split(':')[2])
        connected_to = get_switch_name(link['destination']['dest-node'])
        on_port = int(link['destination']['dest-tp'].split(':')[2])
        status = 'Up'

        # Find reverse path
        bidirectional = 'No'
        for other in links:
            if other['source']['source-tp'] == link['destination']['dest-tp'] and \
                other['destination']['dest-tp'] == link['source']['source-tp']:
                    bidirectional = 'Yes'
                    break

        # Find link in configuration
        build = 'Wrong Cabling'
        for defined in LINKS:
            if defined['destination'] == device and defined['destination_port'] == port and \
                defined['source'] == connected_to and defined['source_port'] == on_port:
                    build = 'Good'
                    break

        if ARGS.show_id:
            device += ' (' + link['source']['source-node'] + ')'
            connected_to += ' (' + link['destination']['dest-node'] + ')'

        rows.append([device, port, connected_to, on_port, status, bidirectional, build])

    # Loop through configured links and check if alive
    for defined in LINKS:
        found_forward = False
        found_reverse = False
        for link in links:
            device = get_switch_name(link['source']['source-node'])
            port = int(link['source']['source-tp'].split(':')[2])
            connected_to = get_switch_name(link['destination']['dest-node'])
            on_port = int(link['destination']['dest-tp'].split(':')[2])
            
            if defined['destination'] == device and defined['destination_port'] == port and \
                defined['source'] == connected_to and defined['source_port'] == on_port:
                    found_forward = True
                
            if defined['destination'] == connected_to and defined['destination_port'] == on_port and \
                defined['source'] == device and defined['source_port'] == port:
                    found_reverse = True

        device = defined['destination']
        port = int(defined['destination_port'])
        connected_to = defined['source']
        on_port = int(defined['source_port'])

        if ARGS.show_id:
            device += ' (' + get_switch_nodename(device) + ')'
            connected_to += ' (' + get_switch_nodename(connected_to) + ')' 

        if not found_forward and found_reverse:
            rows.append([device, port, connected_to, on_port, 'Down', '', 'Required'])
        elif not found_forward and not found_reverse:
            rows.append([device, port, connected_to, on_port, 'Not Connected', '', 'Required'])

    # Filter entries
    if ARGS.filter:
        test = re.compile(ARGS.filter, re.IGNORECASE)
        new_rows = []
        for row in rows:
            if test.match(row[0]) or test.match(row[2]):
                new_rows.append(row)
        rows = new_rows

    # Sort and print table
    rows = sorted(rows, key=operator.itemgetter(1, 0))
    for row in rows:
        ptable.add_row(row)
    print ptable.get_string(sortby=('Device'))

if __name__ == '__main__':
    main()

